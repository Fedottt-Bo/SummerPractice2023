<!DOCTYPE html>

<html>

<head>
  <title>Web GPU try</title>

  <script type="text/javascript" src="gl-matrix.js"></script>
  <script type="text/javascript">
    const format = 'bgra8unorm';

    var cubeData =
    {
      vertices:
      [
        // position     // color
        // front
        -1, -1,  1,     0, 0, 1,
         1, -1,  1,     0, 0, 1,
         1,  1,  1,     0, 0, 1,
         1,  1,  1,     0, 0, 1,
        -1,  1,  1,     0, 0, 1,
        -1, -1,  1,     0, 0, 1,

        // right
         1, -1,  1,     0, 1, 0,
         1, -1, -1,     0, 1, 0,
         1,  1, -1,     0, 1, 0,
         1,  1, -1,     0, 1, 0,
         1,  1,  1,     0, 1, 0,
         1, -1,  1,     0, 1, 0,

        // back
        -1, -1, -1,     1, 0, 0,
        -1,  1, -1,     1, 0, 0,
         1,  1, -1,     1, 0, 0,
         1,  1, -1,     1, 0, 0,
         1, -1, -1,     1, 0, 0,
        -1, -1, -1,     1, 0, 0,

        // left
        -1, -1,  1,     1, 1, 0,
        -1,  1,  1,     1, 1, 0,
        -1,  1, -1,     1, 1, 0,
        -1,  1, -1,     1, 1, 0,
        -1, -1, -1,     1, 1, 0,
        -1, -1,  1,     1, 1, 0,

        // top
        -1,  1,  1,     1, 0, 1,
         1,  1,  1,     1, 0, 1,
         1,  1, -1,     1, 0, 1,
         1,  1, -1,     1, 0, 1,
        -1,  1, -1,     1, 0, 1,
        -1,  1,  1,     1, 0, 1,

        // bottom
        -1, -1,  1,     0, 1, 1,
        -1, -1, -1,     0, 1, 1,
         1, -1, -1,     0, 1, 1,
         1, -1, -1,     0, 1, 1,
         1, -1,  1,     0, 1, 1,
        -1, -1,  1,     0, 1, 1
      ],
      indices:
      [
         0,  1,  2,  3,  4,  5,
         6,  7,  8,  9, 10, 11,
        12, 13, 14, 15, 16, 17,
        18, 19, 20, 21, 22, 23,
        24, 25, 26, 27, 28, 29,
        30, 31, 32, 33, 34, 35
      ]
    };

    async function InitWebGPU() {
      if (!navigator.gpu) {
        let msg = 'Your current browser does not support WebGPU!';

        console.log(msg);
        throw msg;
      }

      const canvas = document.getElementById('canvas-webgpu');
      const adapter = await navigator.gpu.requestAdapter();
      const device = await adapter.requestDevice();
      const context = canvas.getContext('webgpu');

      context.configure({
        device: device,
        format: format,
        alphaMode: 'opaque'
      });

      return { gpu : navigator.gpu, adapter : adapter, device : device, context : context };
    }

    async function HelloTriangle() {
      let gpu = await InitWebGPU();
      let device = gpu.device;

      const vert_buffer = device.createBuffer({
        size: cubeData.vertices.length * 4,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Float32Array(vert_buffer.getMappedRange()).set(new Float32Array(cubeData.vertices));
      vert_buffer.unmap();

      const ind_buffer = device.createBuffer({
        size: cubeData.indices.length * 4,
        usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Uint32Array(ind_buffer.getMappedRange()).set(new Uint32Array(cubeData.indices));
      ind_buffer.unmap();

      let model_elements = cubeData.indices.length;

      const pipeline = device.createRenderPipeline({
        layout:'auto',
        vertex: {
          module: device.createShaderModule({ code:
            `struct Output {
              @builtin(position) Position : vec4<f32>,
              @location(0) vColor : vec4<f32>,
            };
            @vertex
            fn main(@location(0) pos: vec4<f32>, @location(1) color: vec4<f32>) -> Output {
                var output: Output;
                output.Position = pos;
                output.vColor = color;
                return output;
            }` }),
          buffers:
          [
            {
              arrayStride: 4 * (3 + 3),
              attributes:
              [
                {
                  shaderLocation: 0,
                  format: 'float32x3',
                  offset: 0
                },
                {
                  shaderLocation: 1,
                  format: 'float32x3',
                  offset: 12
                }
              ]
            }
          ],
          entryPoint: "main"
        },
        fragment: {
            module: device.createShaderModule({ code:
              `@fragment
              fn main(@location(0) vColor: vec4<f32>) -> @location(0) vec4<f32> {
                return vColor;
              }` }),
            entryPoint: "main",
            targets: [{ format: format }]
        },
        primitive: {
          topology: "triangle-list",
        }
      });

      const commandEncoder = device.createCommandEncoder();
      const textureView = gpu.context.getCurrentTexture().createView();
      const renderPass = commandEncoder.beginRenderPass({
          colorAttachments: [{
              view: textureView,
              clearValue: { r: 0.5, g: 0.5, b: 0.8, a: 1.0 },
              loadOp: 'clear',
              storeOp: 'store'
          }]
      });

      renderPass.setPipeline(pipeline);
      renderPass.setVertexBuffer(0, vert_buffer);
      renderPass.setIndexBuffer(ind_buffer, "uint32");
      renderPass.drawIndexed(model_elements, 1, 0, 0);
      renderPass.end();

      device.queue.submit([commandEncoder.finish()]);
    }
  </script>
</head>

<body onload="HelloTriangle()">
  <canvas id="canvas-webgpu" style="border: none;" width="1024" height="1024"></canvas><br>
</body>
